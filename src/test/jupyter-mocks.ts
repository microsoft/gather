import { Cell, ICellModel } from "@jupyterlab/cells";
import { IChangedArgs } from "@jupyterlab/coreutils";
import { IDocumentManager } from "@jupyterlab/docmanager";
import { DocumentRegistry, IDocumentWidget } from "@jupyterlab/docregistry";
import {
  INotebookModel,
  INotebookTracker,
  NotebookModel,
  NotebookPanel
} from "@jupyterlab/notebook";
import { IModelDB, IObservableJSON, IObservableUndoableList } from "@jupyterlab/observables";
import { Contents, Kernel, ServiceManager } from "@jupyterlab/services";
import { ISignal } from "@lumino/signaling";
import { Widget } from "@lumino/widgets";

/**
 * IMPLEMENTATIONS OF JUPYTER INTERFACES.
 * Automatically generated by VSCode.
 */

export class MockNotebook implements INotebookModel {
  cells: IObservableUndoableList<ICellModel>;
  contentFactory: NotebookModel.IContentFactory;
  nbformat: number;
  nbformatMinor: number;
  metadata: IObservableJSON;
  deletedCells: string[];
  contentChanged: ISignal<this, void>;
  stateChanged: ISignal<this, IChangedArgs<any, string>>;
  dirty: boolean;
  readOnly: boolean;
  defaultKernelName: string;
  defaultKernelLanguage: string;
  modelDB: IModelDB;
  toString(): string {
    throw new Error("Method not implemented.");
  }
  fromString(value: string): void {
    throw new Error("Method not implemented.");
  }
  toJSON(): import("@lumino/coreutils").JSONValue {
    throw new Error("Method not implemented.");
  }
  fromJSON(value: any): void {
    throw new Error("Method not implemented.");
  }
  initialize(): void {
    throw new Error("Method not implemented.");
  }
  isDisposed: boolean;
  dispose(): void {
    throw new Error("Method not implemented.");
  }
}

export class MockDocumentManager implements IDocumentManager {
  registry: DocumentRegistry;
  services: ServiceManager.IManager;
  activateRequested: ISignal<this, string>;
  autosave: boolean;
  autosaveInterval: number;
  cloneWidget(widget: Widget): IDocumentWidget<Widget, DocumentRegistry.IModel> {
    throw new Error("Method not implemented.");
  }
  closeAll(): Promise<void> {
    throw new Error("Method not implemented.");
  }
  closeFile(path: string): Promise<void> {
    throw new Error("Method not implemented.");
  }
  contextForWidget(widget: Widget): DocumentRegistry.IContext<DocumentRegistry.IModel> {
    throw new Error("Method not implemented.");
  }
  copy(fromFile: string, toDir: string): Promise<Contents.IModel> {
    throw new Error("Method not implemented.");
  }
  createNew(path: string, widgetName?: string, kernel?: Partial<Kernel.IModel>): Widget {
    throw new Error("Method not implemented.");
  }
  deleteFile(path: string): Promise<void> {
    throw new Error("Method not implemented.");
  }
  findWidget(path: string, widgetName?: string): IDocumentWidget<Widget, DocumentRegistry.IModel> {
    throw new Error("Method not implemented.");
  }
  newUntitled(options: Contents.ICreateOptions): Promise<Contents.IModel> {
    throw new Error("Method not implemented.");
  }
  open(
    path: string,
    widgetName?: string,
    kernel?: Partial<Kernel.IModel>,
    options?: DocumentRegistry.IOpenOptions
  ): IDocumentWidget<Widget, DocumentRegistry.IModel> {
    throw new Error("Method not implemented.");
  }
  openOrReveal(
    path: string,
    widgetName?: string,
    kernel?: Partial<import("@jupyterlab/services").Kernel.IModel>,
    options?: import("@jupyterlab/docregistry").DocumentRegistry.IOpenOptions
  ): IDocumentWidget<Widget, DocumentRegistry.IModel> {
    throw new Error("Method not implemented.");
  }
  overwrite(oldPath: string, newPath: string): Promise<Contents.IModel> {
    throw new Error("Method not implemented.");
  }
  rename(oldPath: string, newPath: string): Promise<Contents.IModel> {
    throw new Error("Method not implemented.");
  }
  isDisposed: boolean;
  dispose(): void {
    throw new Error("Method not implemented.");
  }
}

export class MockNotebookTracker implements INotebookTracker {
  activeCell: Cell;
  activeCellChanged: ISignal<this, Cell>;
  selectionChanged: ISignal<this, void>;
  widgetAdded: ISignal<this, NotebookPanel>;
  currentWidget: NotebookPanel;
  currentChanged: ISignal<this, NotebookPanel>;
  size: number;
  restored: Promise<void>;
  widgetUpdated: ISignal<this, NotebookPanel>;
  find(fn: (obj: NotebookPanel) => boolean): NotebookPanel {
    throw new Error("Method not implemented.");
  }
  forEach(fn: (obj: NotebookPanel) => void): void {
    throw new Error("Method not implemented.");
  }
  filter(fn: (obj: NotebookPanel) => boolean): NotebookPanel[] {
    throw new Error("Method not implemented.");
  }
  has(obj: Widget): boolean {
    throw new Error("Method not implemented.");
  }
  inject(obj: NotebookPanel): void {
    throw new Error("Method not implemented.");
  }
  isDisposed: boolean;
  dispose(): void {
    throw new Error("Method not implemented.");
  }
}
